# AI-Assisted: generated by ChatGPT for the Aetheric Engine client tools.
"""
Stream parsers for Aetheric Engine ASCII and binary messages.

Protocol refs:
- README.md: framing rules for ASCII ($...;) and binary (0xAA/0xBB + 5-byte length).
- secrets.txt: probabilities and fragmentation hints to influence buffering strategy.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import List, Tuple


ASCII_START = ord("$")
ASCII_END = ord(";")
BINARY_HEADERS = (0xAA, 0xBB)


@dataclass
class AsciiMessage:
    payload: str


@dataclass
class BinaryMessage:
    header: int
    payload: bytes
    declared_len: int
    received_len: int
    truncated: bool = False


class StreamParser:
    """
    Incrementally parses mixed ASCII and binary AE frames from a byte stream.

    A single rolling buffer is processed in-order so bytes consumed by a binary
    frame are not reconsidered as ASCII (prevents double-counting when binary
    payloads contain '$' or ';').
    """

    def __init__(self, max_payload: int | None = None) -> None:
        self._ascii_active = False
        self._ascii_buf = bytearray()
        self._buf = bytearray()
        self._max_payload = max_payload

    def feed(self, data: bytes, *, final: bool = False) -> Tuple[List[AsciiMessage], List[BinaryMessage]]:
        self._buf.extend(data)
        ascii_msgs: List[AsciiMessage] = []
        binary_msgs: List[BinaryMessage] = []

        while True:
            if self._ascii_active:
                if not self._buf:
                    break
                b = self._buf.pop(0)
                if b == ASCII_START:
                    # Restart on nested start marker; keep latest start.
                    self._ascii_buf.clear()
                    continue
                if b == ASCII_END:
                    if len(self._ascii_buf) >= 5:
                        payload = self._ascii_buf.decode("ascii", errors="ignore")
                        ascii_msgs.append(AsciiMessage(payload=payload))
                    self._ascii_active = False
                    self._ascii_buf.clear()
                    continue
                if 32 <= b <= 126:
                    self._ascii_buf.append(b)
                continue

            if not self._buf:
                break

            b = self._buf[0]
            if b == ASCII_START:
                self._ascii_active = True
                self._ascii_buf.clear()
                self._buf.pop(0)
                continue

            if b in BINARY_HEADERS:
                if len(self._buf) < 6:
                    # Need more length bytes.
                    if final:
                        # Incomplete header at EOF is discarded.
                        self._buf.clear()
                    break

                header = b
                declared_len = self._decode_length(bytes(self._buf[1:6]))
                total_needed = 6 + declared_len

                if declared_len <= 0 or declared_len > len(self._buf) - 6:
                    # Not enough bytes to satisfy this length; most likely a false header.
                    self._buf.pop(0)
                    continue

                if len(self._buf) < total_needed:
                    if final:
                        payload = bytes(self._buf[6:])
                        payload = self._trim_excess(payload)
                        binary_msgs.append(
                            BinaryMessage(
                                header=header,
                                payload=payload,
                                declared_len=declared_len,
                                received_len=len(payload),
                                truncated=True,
                            )
                        )
                        self._buf.clear()
                    break

                payload = bytes(self._buf[6:total_needed])
                payload = self._trim_excess(payload)
                binary_msgs.append(
                    BinaryMessage(
                        header=header,
                        payload=payload,
                        declared_len=declared_len,
                        received_len=len(payload),
                        truncated=False,
                    )
                )
                del self._buf[:total_needed]
                continue

            # Drop non-header/non-ASCII-start byte.
            self._buf.pop(0)

        return ascii_msgs, binary_msgs

    def _trim_excess(self, payload: bytes) -> bytes:
        if self._max_payload is None:
            return payload
        if len(payload) <= self._max_payload:
            return payload
        return payload[: self._max_payload]

    def _decode_length(self, length_bytes: bytes) -> int:
        """
        AE binary frames in this capture use little-endian 5-byte lengths
        (see scenarios.md guidance). Using big-endian here would create
        enormous lengths that swallow subsequent frames.
        """
        return int.from_bytes(length_bytes, byteorder="little")

    def flush(self) -> Tuple[List[AsciiMessage], List[BinaryMessage]]:
        """
        Flush remaining buffers marking truncation when applicable.
        """
        return self.feed(b"", final=True)
