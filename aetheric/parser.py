# AI-Assisted: generated by ChatGPT for the Aetheric Engine client tools.
"""
Stream parsers for Aetheric Engine ASCII and binary messages.

Protocol refs:
- README.md: framing rules for ASCII ($...;) and binary (0xAA/0xBB + 5-byte length).
- secrets.txt: probabilities and fragmentation hints to influence buffering strategy.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import List, Sequence, Tuple


ASCII_START = ord("$")
ASCII_END = ord(";")
BINARY_HEADERS = (0xAA, 0xBB)


@dataclass
class AsciiMessage:
    payload: str


@dataclass
class BinaryMessage:
    header: int
    payload: bytes
    declared_len: int
    received_len: int
    truncated: bool = False


class StreamParser:
    """
    Incrementally parses mixed ASCII and binary AE frames from a byte stream.

    Two independent buffers are used because ASCII and binary frames can interleave.
    """

    def __init__(self, max_payload: int | None = None) -> None:
        self._ascii_active = False
        self._ascii_buf = bytearray()
        self._binary_buf = bytearray()
        self._max_payload = max_payload

    def feed(self, data: bytes, *, final: bool = False) -> Tuple[List[AsciiMessage], List[BinaryMessage]]:
        ascii_msgs = self._feed_ascii(data)
        binary_msgs = self._feed_binary(data, final=final)
        return ascii_msgs, binary_msgs

    def _feed_ascii(self, data: Sequence[int]) -> List[AsciiMessage]:
        msgs: List[AsciiMessage] = []
        for b in data:
            if b == ASCII_START:
                self._ascii_active = True
                self._ascii_buf.clear()
                continue

            if not self._ascii_active:
                continue

            if b == ASCII_START:
                # Restart on nested start marker; keep earliest start per PLAN.md.
                self._ascii_buf.clear()
                continue

            if b == ASCII_END:
                if len(self._ascii_buf) >= 5:
                    payload = self._ascii_buf.decode("ascii", errors="ignore")
                    msgs.append(AsciiMessage(payload=payload))
                self._ascii_active = False
                self._ascii_buf.clear()
                continue

            # Keep printable ASCII only; ignore delimiters per README.md guidance.
            if 32 <= b <= 126:
                self._ascii_buf.append(b)
        return msgs

    def _trim_excess(self, payload: bytes) -> bytes:
        if self._max_payload is None:
            return payload
        if len(payload) <= self._max_payload:
            return payload
        return payload[: self._max_payload]

    def _decode_length(self, length_bytes: bytes) -> int:
        """
        Length is nominally big-endian (README.md), but scenarios.md shows
        little-endian fragments such as cb0c000000 -> 3275. Prefer little-endian
        when the byte pattern ends with zeros (suggesting LE) and yields a
        smaller, realistic length; otherwise fall back to big-endian.
        """
        big = int.from_bytes(length_bytes, byteorder="big")
        little = int.from_bytes(length_bytes, byteorder="little")

        if length_bytes[-3:] == b"\x00\x00\x00" and 0 < little < big:
            return little
        return big

    def _feed_binary(self, data: bytes, final: bool) -> List[BinaryMessage]:
        msgs: List[BinaryMessage] = []
        self._binary_buf.extend(data)

        while True:
            start_idx = self._find_header()
            if start_idx is None:
                # No header found; keep buffer small to avoid unbounded growth.
                if len(self._binary_buf) > 1024:
                    self._binary_buf.clear()
                break

            if start_idx:
                del self._binary_buf[:start_idx]

            if len(self._binary_buf) < 6:
                break

            header = self._binary_buf[0]
            declared_len = self._decode_length(self._binary_buf[1:6])
            total_needed = 6 + declared_len

            if len(self._binary_buf) >= total_needed:
                payload = bytes(self._binary_buf[6:total_needed])
                payload = self._trim_excess(payload)
                msgs.append(
                    BinaryMessage(
                        header=header,
                        payload=payload,
                        declared_len=declared_len,
                        received_len=len(payload),
                        truncated=False,
                    )
                )
                del self._binary_buf[:total_needed]
                continue

            if final:
                payload = bytes(self._binary_buf[6:])
                payload = self._trim_excess(payload)
                msgs.append(
                    BinaryMessage(
                        header=header,
                        payload=payload,
                        declared_len=declared_len,
                        received_len=len(payload),
                        truncated=True,
                    )
                )
                self._binary_buf.clear()
            break

        return msgs

    def _find_header(self) -> int | None:
        for idx, b in enumerate(self._binary_buf):
            if b in BINARY_HEADERS:
                return idx
        return None

    def flush(self) -> Tuple[List[AsciiMessage], List[BinaryMessage]]:
        """
        Flush remaining buffers marking truncation when applicable.
        """
        return self.feed(b"", final=True)
