# AI-Assisted: generated by ChatGPT for the Aetheric Engine client tools.
"""
Hidden message heuristics inspired by PLAN.md.

Strategy highlights:
- Preserve arrival order via DB idx fields.
- Inspect concatenated ASCII and grouped binary payloads (AA vs BB).
- Attempt base64/hex decoding, zlib/gzip inflation, and entropy checks.
"""

from __future__ import annotations

import base64
import gzip
import hashlib
import io
import math
import sqlite3
import zlib
from dataclasses import dataclass
from pathlib import Path
from typing import List


def _sha256(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()


def _entropy(data: bytes) -> float:
    if not data:
        return 0.0
    freq = [0] * 256
    for b in data:
        freq[b] += 1
    probs = [c / len(data) for c in freq if c]
    return -sum(p * math.log2(p) for p in probs)


@dataclass
class Attempt:
    name: str
    success: bool
    sha256: str
    preview: str
    entropy: float


@dataclass
class AnalysisReport:
    ascii_concat: str
    ascii_sha256: str
    aa_count: int
    bb_count: int
    attempts: List[Attempt]


def _load_payloads(db_path: Path):
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute("SELECT idx, payload FROM msgascii ORDER BY idx")
    ascii_payloads = [row[1] for row in cur.fetchall()]

    cur.execute("SELECT header, payload FROM msgbinary ORDER BY idx")
    aa_payloads = []
    bb_payloads = []
    for header, payload in cur.fetchall():
        if header == 0xAA:
            aa_payloads.append(payload)
        elif header == 0xBB:
            bb_payloads.append(payload)
    conn.close()
    return ascii_payloads, aa_payloads, bb_payloads


def _attempt_base64(data: bytes) -> Attempt:
    try:
        decoded = base64.b64decode(data, validate=True)
        return Attempt("base64", True, _sha256(decoded), decoded[:64].decode("latin1", errors="replace"), _entropy(decoded))
    except Exception:
        return Attempt("base64", False, _sha256(data), data[:64].decode("latin1", errors="replace"), _entropy(data))


def _attempt_hex(data: bytes) -> Attempt:
    try:
        decoded = bytes.fromhex(data.decode("ascii"))
        return Attempt("hex", True, _sha256(decoded), decoded[:64].decode("latin1", errors="replace"), _entropy(decoded))
    except Exception:
        return Attempt("hex", False, _sha256(data), data[:64].decode("latin1", errors="replace"), _entropy(data))


def _attempt_zlib(data: bytes) -> Attempt:
    try:
        decoded = zlib.decompress(data)
        return Attempt("zlib", True, _sha256(decoded), decoded[:64].decode("latin1", errors="replace"), _entropy(decoded))
    except Exception:
        return Attempt("zlib", False, _sha256(data), data[:64].decode("latin1", errors="replace"), _entropy(data))


def _attempt_gzip(data: bytes) -> Attempt:
    try:
        decoded = gzip.decompress(data)
        return Attempt("gzip", True, _sha256(decoded), decoded[:64].decode("latin1", errors="replace"), _entropy(decoded))
    except Exception:
        return Attempt("gzip", False, _sha256(data), data[:64].decode("latin1", errors="replace"), _entropy(data))


def analyze_hidden(db_path: Path) -> AnalysisReport:
    ascii_payloads, aa_payloads, bb_payloads = _load_payloads(db_path)
    ascii_concat = "".join(ascii_payloads)
    ascii_bytes = ascii_concat.encode("utf-8", errors="ignore")

    attempts: List[Attempt] = []
    attempts.append(_attempt_base64(ascii_bytes))
    attempts.append(_attempt_hex(ascii_bytes))

    for idx, payload in enumerate(bb_payloads):
        name = f"bb[{idx}]"
        attempts.append(_attempt_base64(payload))
        attempts[-1].name = name + " base64"
        attempts.append(_attempt_hex(payload))
        attempts[-1].name = name + " hex"
        attempts.append(_attempt_zlib(payload))
        attempts[-1].name = name + " zlib"
        attempts.append(_attempt_gzip(payload))
        attempts[-1].name = name + " gzip"

    return AnalysisReport(
        ascii_concat=ascii_concat,
        ascii_sha256=_sha256(ascii_bytes),
        aa_count=len(aa_payloads),
        bb_count=len(bb_payloads),
        attempts=attempts,
    )
