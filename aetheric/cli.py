# AI-Assisted: generated by ChatGPT for the Aetheric Engine client tools.
"""
Command line interface for capturing, validating, and analyzing AE data.

Commands:
  capture  - connect to AE, persist messages to SQLite, and save raw capture.bin
  validate - replay capture.bin and compare to SQLite contents
  analyze  - run simple transforms on stored data to hunt for hidden messages
"""

from __future__ import annotations

import argparse
import logging
from pathlib import Path
from typing import Sequence

from .capture import capture_stream
from .validator import validate_capture
from .analysis import analyze_hidden

LOG = logging.getLogger("aetheric")


def _configure_logging(verbose: bool) -> None:
    logging.basicConfig(
        level=logging.DEBUG if verbose else logging.INFO,
        format="%(asctime)s %(levelname)s %(name)s :: %(message)s",
    )


def cmd_capture(args: argparse.Namespace) -> int:
    _configure_logging(args.verbose)
    ascii_count, binary_count = capture_stream(
        host=args.host,
        port=args.port,
        jwt=args.jwt,
        db_path=Path(args.db),
        capture_path=Path(args.capture),
        min_messages=args.min_messages,
        read_size=args.read_size,
        timeout=args.timeout,
        max_payload=args.max_payload,
    )
    LOG.info("Stored %s ASCII and %s binary rows into %s", ascii_count, binary_count, args.db)
    LOG.info("Raw capture saved to %s", args.capture)
    return 0


def cmd_validate(args: argparse.Namespace) -> int:
    _configure_logging(args.verbose)
    result = validate_capture(Path(args.capture), Path(args.db), max_payload=args.max_payload)
    if result.ok:
        LOG.info("Validation passed: %s ASCII rows, %s binary rows", result.ascii_count, result.binary_count)
        return 0

    if result.ascii_mismatch:
        LOG.error("ASCII mismatch: %s", result.ascii_mismatch)
    if result.binary_mismatch:
        LOG.error("Binary mismatch: %s", result.binary_mismatch)
    return 1


def cmd_analyze(args: argparse.Namespace) -> int:
    _configure_logging(args.verbose)
    report = analyze_hidden(Path(args.db))
    LOG.info("Concatenated ASCII sha256=%s length=%s", report.ascii_sha256, len(report.ascii_concat))
    LOG.info("AA binary count=%s; BB binary count=%s", report.aa_count, report.bb_count)
    for attempt in report.attempts:
        status = "ok" if attempt.success else "fail"
        LOG.info("Attempt %s %s sha256=%s preview=%s", attempt.name, status, attempt.sha256, attempt.preview)
    return 0


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Aetheric Engine capture + validation toolkit")
    sub = parser.add_subparsers(dest="command", required=True)

    cap = sub.add_parser("capture", help="connect to AE, persist frames, and save raw capture")
    cap.add_argument("--host", required=True, help="AE host")
    cap.add_argument("--port", required=True, type=int, help="AE port")
    cap.add_argument("--jwt", required=True, help="JWT token for AUTH")
    cap.add_argument("--db", default="ae.sqlite", help="SQLite output file")
    cap.add_argument("--capture", default="capture.bin", help="Raw capture output file")
    cap.add_argument("--min-messages", type=int, default=600, help="Stop after this many parsed messages")
    cap.add_argument("--read-size", type=int, default=4096, help="Socket read size")
    cap.add_argument("--timeout", type=float, default=10.0, help="Socket timeout seconds")
    cap.add_argument("--max-payload", type=int, default=None, help="Max payload bytes to keep per message; default stores all")
    cap.add_argument("-v", "--verbose", action="store_true", help="Enable debug logging")
    cap.set_defaults(func=cmd_capture)

    val = sub.add_parser("validate", help="replay capture.bin and compare to SQLite")
    val.add_argument("--db", default="ae.sqlite", help="SQLite file to validate")
    val.add_argument("--capture", default="capture.bin", help="Raw capture to replay")
    val.add_argument("--max-payload", type=int, default=None, help="Max payload bytes to keep per message; use same value as capture when set")
    val.add_argument("-v", "--verbose", action="store_true", help="Enable debug logging")
    val.set_defaults(func=cmd_validate)

    ana = sub.add_parser("analyze", help="run heuristic transforms to hunt for hidden messages")
    ana.add_argument("--db", default="ae.sqlite", help="SQLite file to analyze")
    ana.add_argument("-v", "--verbose", action="store_true", help="Enable debug logging")
    ana.set_defaults(func=cmd_analyze)

    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    return args.func(args)


if __name__ == "__main__":
    raise SystemExit(main())
