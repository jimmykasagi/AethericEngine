# AI-Assisted: generated by ChatGPT for the Aetheric Engine client tools.
"""
TCP capture client for the Aetheric Engine.

Plan alignment:
- Sends AUTH <JWT>, ingests mixed ASCII/Binary frames until >= min_messages parsed.
- Streams raw bytes to capture.bin for replay.
- Persists parsed frames to SQLite tables per PLAN.md and README.md.
"""

from __future__ import annotations

import logging
import socket
from pathlib import Path
from typing import Iterable, Tuple

from .parser import StreamParser
from .storage import SQLiteStorage

LOG = logging.getLogger(__name__)


def _send_auth(sock: socket.socket, jwt: str) -> None:
    payload = f"AUTH {jwt}\n".encode("ascii")
    sock.sendall(payload)
    LOG.debug("Sent AUTH")


def _send_status(sock: socket.socket) -> None:
    sock.sendall(b"STATUS\n")
    LOG.info("STATUS sent; draining remaining data before close")


def capture_stream(
    host: str,
    port: int,
    jwt: str,
    *,
    db_path: Path,
    capture_path: Path,
    min_messages: int = 600,
    timeout: float = 10.0,
    max_payload: int | None = None,
) -> Tuple[int, int]:
    """
    Connect to AE, parse and persist messages, and record a raw capture file.

    Returns (ascii_count, binary_count).
    """
    parser = StreamParser(max_payload=max_payload)
    ascii_count = 0
    binary_count = 0
    draining = False

    def _log_messages(ascii_msgs, binary_msgs) -> None:
        for msg in ascii_msgs:
            LOG.info("ASCII message: %s", msg.payload)
        for msg in binary_msgs:
            LOG.info(
                "Binary message header=%#04x declared=%s received=%s truncated=%s hex=%s",
                msg.header,
                msg.declared_len,
                msg.received_len,
                msg.truncated,
                msg.payload.hex(),
            )

    with socket.create_connection((host, port), timeout=timeout) as sock, open(capture_path, "wb") as capture_file, SQLiteStorage(db_path) as storage:
        sock.settimeout(timeout)
        _send_auth(sock, jwt)

        while True:
            try:
                # No caller-configurable read_size: ask for a large chunk to pull whole message bursts when available.
                chunk = sock.recv(65535)
            except socket.timeout:
                LOG.warning("Socket read timed out; stopping capture")
                break

            if not chunk:
                LOG.info("Socket closed by server")
                break

            capture_file.write(chunk)

            ascii_msgs, binary_msgs = parser.feed(chunk)
            _log_messages(ascii_msgs, binary_msgs)
            ascii_count += storage.save_ascii(ascii_msgs)
            binary_count += storage.save_binary(binary_msgs)

            if not draining and (ascii_count + binary_count) >= min_messages:
                _send_status(sock)
                draining = True
                # Continue loop to drain until remote closes or timeout.

        # Flush any truncated binary payload if the stream cut mid-frame.
        ascii_msgs, binary_msgs = parser.flush()
        _log_messages(ascii_msgs, binary_msgs)
        ascii_count += storage.save_ascii(ascii_msgs)
        binary_count += storage.save_binary(binary_msgs)

    LOG.info("Capture complete: %s ASCII, %s binary", ascii_count, binary_count)
    return ascii_count, binary_count


def replay_capture(path: Path, *, parser: StreamParser | None = None, max_payload: int | None = None) -> Tuple[list, list]:
    """Parse a saved capture.bin into message lists."""
    parser = parser or StreamParser(max_payload=max_payload)
    ascii_msgs_total = []
    binary_msgs_total = []

    with open(path, "rb") as fh:
        while True:
            chunk = fh.read(4096)
            if not chunk:
                break
            ascii_msgs, binary_msgs = parser.feed(chunk)
            ascii_msgs_total.extend(ascii_msgs)
            binary_msgs_total.extend(binary_msgs)
    ascii_msgs, binary_msgs = parser.flush()
    ascii_msgs_total.extend(ascii_msgs)
    binary_msgs_total.extend(binary_msgs)
    return ascii_msgs_total, binary_msgs_total
