# AI-Assisted: generated by ChatGPT for the Aetheric Engine client tools.
"""
Validator that replays capture.bin and compares to SQLite contents.

Supports PLAN.md validation step to ensure the TCP client and parser agree.
"""

from __future__ import annotations

import logging
import sqlite3
from dataclasses import dataclass
from pathlib import Path

from .capture import replay_capture

LOG = logging.getLogger(__name__)


@dataclass
class ValidationResult:
    ok: bool
    ascii_mismatch: str | None = None
    binary_mismatch: str | None = None
    ascii_count: int = 0
    binary_count: int = 0


def _load_db(db_path: Path):
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute("SELECT idx, payload FROM msgascii ORDER BY idx")
    ascii_rows = cur.fetchall()
    cur.execute("SELECT idx, header, payload, declared_len, received_len, truncated FROM msgbinary ORDER BY idx")
    binary_rows = cur.fetchall()
    conn.close()
    return ascii_rows, binary_rows


def validate_capture(capture_path: Path, db_path: Path, *, max_payload: int | None = None) -> ValidationResult:
    ascii_msgs, binary_msgs = replay_capture(capture_path, max_payload=max_payload)
    db_ascii, db_binary = _load_db(db_path)

    if len(ascii_msgs) != len(db_ascii):
        msg = f"ASCII count mismatch: capture={len(ascii_msgs)} db={len(db_ascii)}"
        LOG.error(msg)
        return ValidationResult(False, ascii_mismatch=msg, ascii_count=len(db_ascii), binary_count=len(db_binary))

    for idx, (row_idx, payload) in enumerate(db_ascii):
        if ascii_msgs[idx].payload != payload:
            msg = f"ASCII payload mismatch at db idx {row_idx}"
            LOG.error(msg)
            return ValidationResult(False, ascii_mismatch=msg, ascii_count=len(db_ascii), binary_count=len(db_binary))

    if len(binary_msgs) != len(db_binary):
        msg = f"Binary count mismatch: capture={len(binary_msgs)} db={len(db_binary)}"
        LOG.error(msg)
        return ValidationResult(False, binary_mismatch=msg, ascii_count=len(db_ascii), binary_count=len(db_binary))

    for idx, (row_idx, header, payload, declared_len, received_len, truncated) in enumerate(db_binary):
        bm = binary_msgs[idx]
        if bm.header != header:
            msg = f"Binary header mismatch at db idx {row_idx}"
            LOG.error(msg)
            return ValidationResult(False, binary_mismatch=msg, ascii_count=len(db_ascii), binary_count=len(db_binary))
        if bm.payload != payload:
            msg = f"Binary payload mismatch at db idx {row_idx}"
            LOG.error(msg)
            return ValidationResult(False, binary_mismatch=msg, ascii_count=len(db_ascii), binary_count=len(db_binary))
        if bm.declared_len != declared_len or bm.received_len != received_len or int(bm.truncated) != truncated:
            msg = f"Binary length/truncation mismatch at db idx {row_idx}"
            LOG.error(msg)
            return ValidationResult(False, binary_mismatch=msg, ascii_count=len(db_ascii), binary_count=len(db_binary))

    LOG.info("Validation succeeded")
    return ValidationResult(True, ascii_count=len(db_ascii), binary_count=len(db_binary))
