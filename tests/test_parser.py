# AI-Assisted: generated by ChatGPT for the Aetheric Engine client tools.
import unittest

from aetheric.parser import ASCII_END, ASCII_START, BINARY_HEADERS, AsciiMessage, BinaryMessage, StreamParser


class StreamParserTests(unittest.TestCase):
    def test_ascii_basic_and_nested(self) -> None:
        parser = StreamParser()
        data = b"noise$HELLO;junk"
        ascii_msgs, binary_msgs = parser.feed(data)
        self.assertEqual([m.payload for m in ascii_msgs], ["HELLO"])
        self.assertEqual(binary_msgs, [])

        ascii_msgs, _ = parser.feed(b"$BADDR$HELLO;")
        self.assertEqual([m.payload for m in ascii_msgs], ["HELLO"])

    def test_ascii_concatenated(self) -> None:
        parser = StreamParser()
        ascii_msgs, _ = parser.feed(b"$ABCDE;$FGHIJ;")
        self.assertEqual([m.payload for m in ascii_msgs], ["ABCDE", "FGHIJ"])

    def test_ascii_fragmented_across_messages(self) -> None:
        parser = StreamParser()
        # First chunk has start marker but no terminator, mimicking scenarios.md broken ASCII.
        ascii_msgs, _ = parser.feed(b"$STARTING-BUT")
        self.assertEqual(ascii_msgs, [])

        ascii_msgs, _ = parser.feed(b"-NO-END-YET")
        self.assertEqual(ascii_msgs, [])

        ascii_msgs, _ = parser.feed(b"-FINALLY;")
        self.assertEqual([m.payload for m in ascii_msgs], ["STARTING-BUT-NO-END-YET-FINALLY"])

    def test_binary_complete(self) -> None:
        parser = StreamParser()
        payload = b"abc"
        length = len(payload).to_bytes(5, "big")
        data = bytes([BINARY_HEADERS[0]]) + length + payload
        _, binary_msgs = parser.feed(data)
        self.assertEqual(len(binary_msgs), 1)
        self.assertEqual(binary_msgs[0].payload, payload)
        self.assertFalse(binary_msgs[0].truncated)

    def test_binary_fragmented_and_truncated(self) -> None:
        parser = StreamParser()
        payload = b"12345"
        length = len(payload).to_bytes(5, "big")
        chunk1 = bytes([BINARY_HEADERS[1]]) + length[:2]
        chunk2 = length[2:] + payload[:2]
        chunk3 = payload[2:]

        _, msgs = parser.feed(chunk1)
        self.assertEqual(msgs, [])
        _, msgs = parser.feed(chunk2)
        self.assertEqual(msgs, [])
        _, msgs = parser.feed(chunk3)
        self.assertEqual(len(msgs), 1)
        self.assertEqual(msgs[0].payload, payload)
        self.assertFalse(msgs[0].truncated)

        parser = StreamParser()
        _, msgs = parser.feed(chunk1 + chunk2, final=False)
        # Simulate stream end; should mark truncation.
        _, msgs_final = parser.feed(b"", final=True)
        self.assertEqual(len(msgs_final), 1)
        self.assertTrue(msgs_final[0].truncated)

    def test_binary_fragmented_little_endian_length(self) -> None:
        parser = StreamParser()
        payload = bytes(range(256)) * 12 + b"tail"
        declared_len = len(payload)
        length_le = declared_len.to_bytes(5, "little")
        # Spread across four fragments similar to scenarios.md example.
        chunk1 = bytes([BINARY_HEADERS[0]]) + length_le + payload[:1000]
        chunk2 = payload[1000:2000]
        chunk3 = payload[2000:3000]
        chunk4 = payload[3000:]

        collected = []
        for chunk in (chunk1, chunk2, chunk3, chunk4):
            _, msgs = parser.feed(chunk)
            collected.extend(msgs)

        self.assertEqual(len(collected), 1)
        msg = collected[0]
        self.assertEqual(msg.declared_len, declared_len)
        self.assertEqual(msg.received_len, declared_len)
        self.assertFalse(msg.truncated)
        self.assertEqual(msg.payload, payload)


if __name__ == "__main__":
    unittest.main()
